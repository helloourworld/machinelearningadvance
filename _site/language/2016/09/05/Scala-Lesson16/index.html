<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="baidu-site-verification" content="g89MuzujW3" />
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="关于机器学习，关于大数据，关于你身边的金融，关于我们的生活... | LijunYu">
    <meta name="keywords"  content="LijunYu, 包包的老公, 大数据, 机器学习, CFA, Machine Learning, Big Data">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <link rel="alternatecss" type="application/rss+xml" title="“Lijun Yu's Blog”" href="http://helloourworld.github.io/feed.xml">
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>

    <title>Scala Lesson 16 - Maching Learning | 机器学习笔记</title>

    <link rel="canonical" href="http://machinelearningadvance.com/language/2016/09/05/Scala-Lesson16/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- ga & ba script hoook -->
    <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Big Data Memo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/category/">Category</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/images/background.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/images/background.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#Scala" title="Scala">Scala</a>
                        
                    </div>
                    <h1>Scala Lesson 16</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by Big Data Memo on September 5, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<p>链接：https://segmentfault.com/a/1190000005043288#articleHeader56</p>

<h1 id="databricks-scala-">Databricks Scala 编程风格指南</h1>

<h2 id="disclaimer">声明 (Disclaimer)</h2>

<p>The Chinese version of the <a href="https://github.com/databricks/scala-style-guide">Databricks Scala Guide</a> is contributed and maintained by community member <a href="https://github.com/Hawstein">Hawstein</a>. We do not guarantee that it will always be kept up-to-date.</p>

<p>本文档翻译自 <a href="https://github.com/databricks/scala-style-guide">Databricks Scala Guide</a>，目前由 <a href="https://github.com/Hawstein">Hawstein</a> 进行维护。由于是利用业余时间进行翻译并维护，因此该中文文档并不保证总是与<a href="https://github.com/databricks/scala-style-guide">原文档</a>一样处于最新版本，不过我会尽可能及时地去更新它。</p>

<h2 id="section">前言</h2>

<p>Spark 有超过 800 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目。这份指南是在我们指导，或是与 Spark 贡献者及 <a href="http://databricks.com/">Databricks</a> 工程团队一起工作时总结出来的。</p>

<p>代码由作者__一次编写__，然后由大量工程师__多次阅读并修改__。事实上，大部分的 bug 来源于后人对代码的修改，因此我们需要长期去优化我们的代码，提升代码的可读性和可维护性。达到这个目标最好的方式就是编写简单易懂的代码。</p>

<p>Scala 是一种强大到令人难以置信的多范式编程语言。我们总结出了以下指南，它可以很好地应用在一个高速发展的项目。当然，这个指南并非绝对，根据团队需求的不同，可以有不同的标准。</p>

<h2 id="a-nametoca"><a name="TOC">目录</a></h2>

<ol>
  <li><a href="#history">文档历史</a></li>
  <li><a href="#syntactic">语法风格</a>
    - <a href="#naming">命名约定</a>
    - <a href="#linelength">一行长度</a>
    - <a href="#rule_of_30">30 法则</a>
    - <a href="#indent">空格与缩进</a>
    - <a href="#blanklines">空行</a>
    - <a href="#parentheses">括号</a>
    - <a href="#curly">大括号</a>
    - <a href="#long_literal">长整型字面量</a>
    - <a href="#doc">文档风格</a>
    - <a href="#ordering_class">类内秩序</a>
    - <a href="#imports">Imports</a>
    - <a href="#pattern-matching">模式匹配</a>
    - <a href="#infix">中缀方法</a>
    - <a href="#anonymous">匿名方法</a></li>
  <li><a href="#lang">Scala 语言特性</a>
    - <a href="#apply_method">apply 方法</a>
    - <a href="#override_modifier">override 修饰符</a>
    - <a href="#destruct_bind">解构绑定</a>
    - <a href="#call_by_name">按名称传参</a>
    - <a href="#multi-param-list">多参数列表</a>
    - <a href="#symbolic_methods">符号方法 (运算符重载)</a>
    - <a href="#type_inference">类型推导</a>
    - <a href="#return">Return 语句</a>
    - <a href="#recursion">递归及尾递归</a>
    - <a href="#implicits">Implicits</a>
    - <a href="#exception">异常处理 (Try 还是 try)</a>
    - <a href="#option">Options</a>
    - <a href="#chaining">单子链接</a></li>
  <li><a href="#concurrency">并发</a>
    - <a href="#concurrency-scala-collection">Scala concurrent.Map</a>
    - <a href="#concurrency-sync-vs-map">显式同步 vs 并发集合</a>
    - <a href="#concurrency-sync-vs-atomic">显式同步 vs 原子变量 vs @volatile</a>
    - <a href="#concurrency-private-this">私有字段</a>
    - <a href="#concurrency-isolation">隔离</a></li>
  <li><a href="#perf">性能</a>
    - <a href="#perf-microbenchmarks">Microbenchmarks</a>
    - <a href="#perf-whileloops">Traversal 与 zipWithIndex</a>
    - <a href="#perf-option">Option 与 null</a>
    - <a href="#perf-collection">Scala 集合库</a>
    - <a href="#perf-private">private[this]</a></li>
  <li><a href="#java">与 Java 的互操作性</a>
    - <a href="#java-missing-features">Scala 中缺失的 Java 特性</a>
    - <a href="#java-traits">Traits 与抽象类</a>
    - <a href="#java-type-alias">类型别名</a>
    - <a href="#java-default-param-values">默认参数值</a>
    - <a href="#java-multi-param-list">多参数列表</a>
    - <a href="#java-varargs">可变参数</a>
    - <a href="#java-implicits">Implicits</a>
    - <a href="#java-companion-object">伴生对象, 静态方法与字段</a></li>
  <li><a href="#misc">其它</a>
    - <a href="#misc_currentTimeMillis_vs_nanoTime">优先使用 nanoTime 而非 currentTimeMillis</a>
    - <a href="#misc_uri_url">优先使用 URI 而非 URL</a></li>
</ol>

<h2 id="a-namehistorya"><a name="history">文档历史</a></h2>
<ul>
  <li>2015-03-16: 最初版本。</li>
  <li>2015-05-25: 增加 <a href="#override_modifier">override 修饰符</a> 一节。</li>
  <li>2015-08-23: 把一些规则的严重程度从「不要」降级到「避免」。</li>
  <li>2015-11-17: 更新 <a href="#apply_method">apply 方法</a> 一节：伴生对象中的 apply 方法应该返回其伴生类。</li>
  <li>2015-11-17: 该指南被翻译成<a href="README-ZH.md">中文</a>，由 <a href="https://github.com/Hawstein">Hawstein</a> 进行维护，中文文档并不保证总是与原文档一样处于最新版本。</li>
  <li>2015-12-14: 该指南被翻译成<a href="README-KO.md">韩文</a>, 韩文版本由 <a href="https://github.com/HyukjinKwon">Hyukjin Kwon</a> 进行翻译并且由 <a href="https://github.com/yunpark93">Yun Park</a>, <a href="https://github.com/swkimme">Kevin (Sangwoo) Kim</a>, <a href="https://github.com/RetrieverJo">Hyunje Jo</a> 和 <a href="https://github.com/socialpercon">Woochel Choi</a> 进行校对。韩文版本并不保证总是与原文档一样处于最新版本。</li>
  <li>2016-06-15: 增加 <a href="#anonymous">匿名方法</a> 一节。</li>
</ul>

<h2 id="a-namesyntactica"><a name="syntactic">语法风格</a></h2>

<h3 id="a-namenaminga"><a name="naming">命名约定</a></h3>

<p>我们主要遵循 Java 和 Scala 的标准命名约定。</p>

<ul>
  <li>
    <p>类，trait, 对象应该遵循 Java 中类的命名约定，即 PascalCase 风格。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ClusterManager</span>

<span class="k">trait</span> <span class="nc">Expression</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>包名应该遵循 Java 中包名的命名约定，即使用全小写的 ASCII 字母。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">package</span> <span class="nn">com.databricks.resourcemanager</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>方法/函数应当使用驼峰式风格命名。</p>
  </li>
  <li>
    <p>常量命名使用全大写字母，并将它们放在伴生对象中。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Configuration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">DEFAULT_PORT</span> <span class="k">=</span> <span class="mi">10000</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>枚举命名与类命名一致，使用 PascalCase 风格。</p>
  </li>
  <li>
    <p>注解也应遵循 Java 中的约定，即使用 PascalCase 风格。注意，这一点与 Scala 的官方指南不同。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">MyAnnotation</span> <span class="k">extends</span> <span class="nc">StaticAnnotation</span>
</code></pre>
    </div>
  </li>
</ul>

<h3 id="a-namelinelengtha"><a name="linelength">一行长度</a></h3>

<ul>
  <li>一行长度的上限是 100 个字符。</li>
  <li>唯一的例外是 import 语句和 URL (即便如此，也尽量将它们保持在 100 个字符以下)。</li>
</ul>

<h3 id="a-nameruleof3030-a"><a name="rule_of_30">30 法则</a></h3>

<p>「如果一个元素包含的子元素超过 30 个，那么极有可能出现了严重的问题」 - <a href="http://www.amazon.com/Refactoring-Large-Software-Projects-Restructurings/dp/0470858923">Refactoring in Large Software Projects</a>。</p>

<p>一般来说:</p>

<ul>
  <li>一个方法包含的代码行数不宜超过 30 行。</li>
  <li>一个类包含的方法数量不宜超过 30 个。</li>
</ul>

<h3 id="a-nameindenta"><a name="indent">空格与缩进</a></h3>

<ul>
  <li>
    <p>一般情况下，使用两个空格的缩进。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Wow!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>对于方法声明，如果一行无法容纳下所有的参数，那么使用 4 个空格来缩进它们。返回类型可以与最后一个参数在同一行，也可以放在下一行，使用两个空格缩进。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">newAPIHadoopFile</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span>, <span class="kt">F</span> <span class="k">&lt;:</span> <span class="kt">NewInputFormat</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]](</span>
    <span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">fClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span>
    <span class="n">kClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span>
    <span class="n">vClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="kt">V</span><span class="o">],</span>
    <span class="n">conf</span><span class="k">:</span> <span class="kt">Configuration</span> <span class="o">=</span> <span class="n">hadoopConfiguration</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// method body
</span><span class="o">}</span>

<span class="k">def</span> <span class="n">newAPIHadoopFile</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span>, <span class="kt">F</span> <span class="k">&lt;:</span> <span class="kt">NewInputFormat</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]](</span>
    <span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">fClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span>
    <span class="n">kClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span>
    <span class="n">vClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="kt">V</span><span class="o">],</span>
    <span class="n">conf</span><span class="k">:</span> <span class="kt">Configuration</span> <span class="o">=</span> <span class="n">hadoopConfiguration</span><span class="o">)</span>
  <span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// method body
</span><span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>如果一行无法容纳下类头（即 extends 后面那部分），则把它们放到新的一行，用两个空格缩进，然后在类内空一行再开始函数或字段的定义（或是包的导入）。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="o">(</span>
    <span class="k">val</span> <span class="n">param1</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>  <span class="c1">// 4 space indent for parameters
</span>    <span class="k">val</span> <span class="n">param2</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="k">val</span> <span class="n">param3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">FooInterface</span>  <span class="c1">// 2 space here
</span>  <span class="k">with</span> <span class="nc">Logging</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">firstMethod</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>  <span class="c1">// blank line above
</span><span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>不要使用垂直对齐。它使你的注意力放在代码的错误部分并增大了后人修改代码的难度。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// Don't align vertically
</span><span class="k">val</span> <span class="n">plus</span>     <span class="k">=</span> <span class="s">"+"</span>
<span class="k">val</span> <span class="n">minus</span>    <span class="k">=</span> <span class="s">"-"</span>
<span class="k">val</span> <span class="n">multiply</span> <span class="k">=</span> <span class="s">"*"</span>

<span class="c1">// Do the following
</span><span class="k">val</span> <span class="n">plus</span> <span class="k">=</span> <span class="s">"+"</span>
<span class="k">val</span> <span class="n">minus</span> <span class="k">=</span> <span class="s">"-"</span>
<span class="k">val</span> <span class="n">multiply</span> <span class="k">=</span> <span class="s">"*"</span>
</code></pre>
    </div>
  </li>
</ul>

<h3 id="a-nameblanklinesa"><a name="blanklines">空行</a></h3>

<ul>
  <li>一个空行可以出现在：
    <ul>
      <li>连续的类成员或初始化器（initializers）之间：字段，构造函数，方法，嵌套类，静态初始化器及实例初始化器。
        <ul>
          <li>例外：连续的两个字段之间的空行是可选的（前提是它们之间没有其它代码），这一类空行主要为这些字段做逻辑上的分组。</li>
        </ul>
      </li>
      <li>在方法体内，根据需要，使用空行来为语句创建逻辑上的分组。</li>
      <li>在类的第一个成员之前或最后一个成员之后，空行都是可选的（既不鼓励也不阻止）。</li>
    </ul>
  </li>
  <li>使用一个或两个空行来分隔不同类的定义。</li>
  <li>不鼓励使用过多的空行。</li>
</ul>

<h3 id="a-nameparenthesesa"><a name="parentheses">括号</a></h3>

<ul>
  <li>
    <p>方法声明应该加括号（即使没有参数列表），除非它们是没有副作用（状态改变，IO 操作都认为是有副作用的）的访问器（accessor）。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Job</span> <span class="o">{</span>
  <span class="c1">// Wrong: killJob changes state. Should have ().
</span>  <span class="k">def</span> <span class="n">killJob</span><span class="k">:</span> <span class="kt">Unit</span>

  <span class="c1">// Correct:
</span>  <span class="k">def</span> <span class="n">killJob</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>函数调用应该与函数声明在形式上保持一致，也就是说，如果一个方法声明时带了括号，那调用时也要把括号带上。注意这不仅仅是语法层面的人为约定，当返回对象中定义了 <code class="highlighter-rouge">apply</code> 方法时，这一点还会影响正确性。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span>
<span class="o">}</span>

<span class="k">new</span> <span class="nc">Bar</span><span class="o">().</span><span class="n">foo</span>  <span class="c1">// This returns a Foo
</span><span class="k">new</span> <span class="nc">Bar</span><span class="o">().</span><span class="n">foo</span><span class="o">()</span>  <span class="c1">// This returns an Int!
</span></code></pre>
    </div>
  </li>
</ul>

<h3 id="a-namecurlya"><a name="curly">大括号</a></h3>

<p>即使条件语句或循环语句只有一行时，也请使用大括号。唯一的例外是，当你把 if/else 作为一个单行的三元操作符来使用并且没有副作用时，这时你可以不加大括号。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// Correct:
</span><span class="k">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Wow!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Correct:
</span><span class="k">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="n">statement1</span> <span class="k">else</span> <span class="n">statement2</span>

<span class="c1">// Correct:
</span><span class="k">try</span> <span class="o">{</span>
  <span class="n">foo</span><span class="o">()</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// Wrong:
</span><span class="k">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Wow!"</span><span class="o">)</span>

<span class="c1">// Wrong:
</span><span class="k">try</span> <span class="n">foo</span><span class="o">()</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-namelongliterala"><a name="long_literal">长整型字面量</a></h3>

<p>长整型字面量使用大写的 <code class="highlighter-rouge">L</code> 作为后缀，不要使用小写，因为它和数字 <code class="highlighter-rouge">1</code> 长得很像，常常难以区分。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">longValue</span> <span class="k">=</span> <span class="mi">5432L</span>  <span class="c1">// Do this
</span>
<span class="k">val</span> <span class="n">longValue</span> <span class="k">=</span> <span class="mi">5432</span><span class="n">l</span>  <span class="c1">// Do NOT do this
</span></code></pre>
</div>

<h3 id="a-namedoca"><a name="doc">文档风格</a></h3>

<p>使用 Java Doc 风格，而非 Scala Doc 风格。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="cm">/** This is a correct one-liner, short description. */</span>

<span class="cm">/**
 * This is correct multi-line JavaDoc comment. And
 * this is my second line, and if I keep typing, this would be
 * my third line.
 */</span>

<span class="cm">/** In Spark, we don't use the ScalaDoc style so this
  * is not correct.
  */</span>
</code></pre>
</div>

<h3 id="a-nameorderingclassa"><a name="ordering_class">类内秩序</a></h3>

<p>如果一个类很长，包含许多的方法，那么在逻辑上把它们分成不同的部分并加上注释头，以此组织它们。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataFrame</span> <span class="o">{</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////////
</span>  <span class="c1">// DataFrame operations
</span>  <span class="c1">///////////////////////////////////////////////////////////////////////////
</span>
  <span class="o">...</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////////
</span>  <span class="c1">// RDD operations
</span>  <span class="c1">///////////////////////////////////////////////////////////////////////////
</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<p>当然，强烈不建议把一个类写得这么长，一般只有在构建某些公共 API 时才允许这么做。</p>

<h3 id="a-nameimportsimportsa"><a name="imports">Imports</a></h3>

<ul>
  <li><strong>导入时避免使用通配符</strong>, 除非你需要导入超过 6 个实体或者隐式方法。通配符导入会使代码在面对外部变化时不够健壮。</li>
  <li>始终使用绝对路径来导入包 (如：<code class="highlighter-rouge">scala.util.Random</code>) ，而不是相对路径 (如：<code class="highlighter-rouge">util.Random</code>)。</li>
  <li>此外，导入语句按照以下顺序排序：
    <ul>
      <li><code class="highlighter-rouge">java.*</code> 和 <code class="highlighter-rouge">javax.*</code></li>
      <li><code class="highlighter-rouge">scala.*</code></li>
      <li>第三方库 (<code class="highlighter-rouge">org.*</code>, <code class="highlighter-rouge">com.*</code>, 等)</li>
      <li>项目中的类 (对于 Spark 项目，即 <code class="highlighter-rouge">com.databricks.*</code> 或 <code class="highlighter-rouge">org.apache.spark</code>)</li>
    </ul>
  </li>
  <li>在每一组导入语句内，按照字母序进行排序。</li>
  <li>
    <p>你可以使用 IntelliJ 的「import organizer」来自动处理，请使用以下配置：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>java
javax
_______ blank line _______
scala
_______ blank line _______
all other imports
_______ blank line _______
com.databricks  // or org.apache.spark if you are working on spark
</code></pre>
    </div>
  </li>
</ul>

<h3 id="a-namepattern-matchinga"><a name="pattern-matching">模式匹配</a></h3>

<ul>
  <li>
    <p>如果整个方法就是一个模式匹配表达式，可能的话，可以把 match 关键词与方法声明放在同一行，以此减少一级缩进。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">test</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">msg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>当以闭包形式调用一个函数时，如果只有一个 case 语句，那么把 case 语句与函数调用放在同一行。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">list</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="o">}</span>
</code></pre>
    </div>
    <p>如果有多个 case 语句，把它们缩进并且包起来。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">list</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Foo</span> <span class="o">=&gt;</span>  <span class="o">...</span>
  <span class="k">case</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Bar</span> <span class="o">=&gt;</span>  <span class="o">...</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
</ul>

<h3 id="a-nameinfixa"><a name="infix">中缀方法</a></h3>

<p><strong>避免中缀表示法</strong>，除非是符号方法（即运算符重载）。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// Correct
</span><span class="n">list</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">func</span><span class="o">)</span>
<span class="n">string</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>

<span class="c1">// Wrong
</span><span class="n">list</span> <span class="n">map</span> <span class="o">(</span><span class="n">func</span><span class="o">)</span>
<span class="n">string</span> <span class="n">contains</span> <span class="s">"foo"</span>

<span class="c1">// 重载的运算符应该以中缀形式调用
</span><span class="n">arrayBuffer</span> <span class="o">+=</span> <span class="n">elem</span>
</code></pre>
</div>

<h3 id="a-nameanonymousa"><a name="anonymous">匿名方法</a></h3>

<p>对于匿名方法，<strong>避免使用过多的小括号和花括号</strong>。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// Correct
</span><span class="n">list</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">item</span> <span class="k">=&gt;</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// Correct
</span><span class="n">list</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">item</span> <span class="k">=&gt;</span> <span class="o">...)</span>

<span class="c1">// Wrong
</span><span class="n">list</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">item</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">})</span>

<span class="c1">// Wrong
</span><span class="n">list</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">item</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}}</span>

<span class="c1">// Wrong
</span><span class="n">list</span><span class="o">.</span><span class="n">map</span><span class="o">({</span> <span class="n">item</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">})</span>
</code></pre>
</div>

<h2 id="a-namelangscala-a"><a name="lang">Scala 语言特性</a></h2>

<h3 id="a-nameapplymethodapply-a"><a name="apply_method">apply 方法</a></h3>

<p>避免在类里定义 apply 方法。这些方法往往会使代码的可读性变差，尤其是对于不熟悉 Scala 的人。它也难以被 IDE（或 grep）所跟踪。在最坏的情况下，它还可能影响代码的正确性，正如你在<a href="#parentheses">括号</a>一节中看到的。</p>

<p>然而，将 apply 方法作为工厂方法定义在伴生对象中是可以接受的。在这种情况下，apply 方法应该返回其伴生类的类型。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">TreeNode</span> <span class="o">{</span>
  <span class="c1">// 下面这种定义是 OK 的
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">TreeNode</span> <span class="o">=</span> <span class="o">...</span>

  <span class="c1">// 不要像下面那样定义，因为它没有返回其伴生类的类型：TreeNode
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-nameoverridemodifieroverride-a"><a name="override_modifier">override 修饰符</a></h3>

<p>无论是覆盖具体的方法还是实现抽象的方法，始终都为方法加上 override 修饰符。实现抽象方法时，不加 override 修饰符，Scala 编译器也不会报错。即便如此，我们也应该始终把 override 修饰符加上，以此显式地表示覆盖行为。以此避免由于方法签名不同（而你也难以发现）而导致没有覆盖到本应覆盖的方法。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Parent</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">hello</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="k">extends</span> <span class="nc">Parent</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">scala.collection.Map</span>

  <span class="c1">// 下面的方法没有覆盖 Parent.hello,
</span>  <span class="c1">// 因为两个 Map 的类型是不同的。
</span>  <span class="c1">// 如果我们加上 override 修饰符，编译器就会帮你找出问题并报错。
</span>  <span class="k">def</span> <span class="n">hello</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"This is supposed to override the parent method, but it is actually not!"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-namedestructbinda"><a name="destruct_bind">解构绑定</a></h3>

<p>解构绑定（有时也叫元组提取）是一种在一个表达式中为两个变量赋值的便捷方式。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</code></pre>
</div>

<p>然而，请不要在构造函数中使用它们，尤其是当 <code class="highlighter-rouge">a</code> 和 <code class="highlighter-rouge">b</code> 需要被标记为 <code class="highlighter-rouge">transient</code> 的时候。Scala 编译器会产生一个额外的 Tuple2 字段，而它并不是暂态的（transient）。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
  <span class="c1">// 以下代码无法 work，因为编译器会产生一个非暂态的 Tuple2 指向 a 和 b
</span>  <span class="nd">@transient</span> <span class="k">private</span> <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=</span> <span class="n">someFuncThatReturnsTuple2</span><span class="o">()</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-namecallbynamea"><a name="call_by_name">按名称传参</a></h3>

<p><strong>避免使用按名传参</strong>. 显式地使用 <code class="highlighter-rouge">() =&gt; T</code> 。</p>

<p>背景：Scala 允许按名称来定义方法参数，例如：以下例子是可以成功执行的：</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">print</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">inc</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">a</span>
<span class="o">}</span>

<span class="n">print</span><span class="o">(</span><span class="n">inc</span><span class="o">())</span>
</code></pre>
</div>

<p>在上面的代码中，<code class="highlighter-rouge">inc()</code> 以闭包的形式传递给 <code class="highlighter-rouge">print</code> 函数，并且在 <code class="highlighter-rouge">print</code> 函数中被执行了两次，而不是以数值 <code class="highlighter-rouge">1</code> 传入。按名传参的一个主要问题是在方法调用处，我们无法区分是按名传参还是按值传参。因此无法确切地知道这个表达式是否会被执行（更糟糕的是它可能会被执行多次）。对于带有副作用的表达式来说，这一点是非常危险的。</p>

<h3 id="a-namemulti-param-lista"><a name="multi-param-list">多参数列表</a></h3>

<p><strong>避免使用多参数列表</strong>。它们使运算符重载变得复杂，并且会使不熟悉 Scala 的程序员感到困惑。例如：</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// Avoid this!
</span><span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">secret</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre>
</div>

<p>一个值得注意的例外是，当在定义底层库时，可以使用第二个参数列表来存放隐式（implicit）参数。尽管如此，<a href="#implicits">我们应该避免使用 implicits</a>！</p>

<h3 id="a-namesymbolicmethodsa"><a name="symbolic_methods">符号方法（运算符重载）</a></h3>

<p><strong>不要使用符号作为方法名</strong>，除非你是在定义算术运算的方法（如：<code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">-</code>, <code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">/</code>），否则在任何其它情况下，都不要使用。符号化的方法名让人难以理解方法的意图是什么，来看下面两个例子：</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// 符号化的方法名难以理解
</span><span class="n">channel</span> <span class="o">!</span> <span class="n">msg</span>
<span class="n">stream1</span> <span class="o">&gt;&gt;=</span> <span class="n">stream2</span>

<span class="c1">// 下面的方法意图则不言而喻
</span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
<span class="n">stream1</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">stream2</span><span class="o">)</span>
</code></pre>
</div>

<h3 id="a-nametypeinferencea"><a name="type_inference">类型推导</a></h3>

<p>Scala 的类型推导，尤其是左侧类型推导以及闭包推导，可以使代码变得更加简洁。尽管如此，也有一些情况我们是需要显式地声明类型的：</p>

<ul>
  <li><strong>公有方法应该显式地声明类型</strong>，编译器推导出来的类型往往会使你大吃一惊。</li>
  <li><strong>隐式方法应该显式地声明类型</strong>，否则在增量编译时，它会使 Scala 编译器崩溃。</li>
  <li><strong>如果变量或闭包的类型并非显而易见，请显式声明类型</strong>。一个不错的判断准则是，如果评审代码的人无法在 3 秒内确定相应实体的类型，那么你就应该显式地声明类型。</li>
</ul>

<h3 id="a-namereturnreturn-a"><a name="return">Return 语句</a></h3>

<p><strong>闭包中避免使用 return</strong>。<code class="highlighter-rouge">return</code> 会被编译器转成 <code class="highlighter-rouge">scala.runtime.NonLocalReturnControl</code> 异常的 <code class="highlighter-rouge">try/catch</code> 语句，这可能会导致意外行为。请看下面的例子：</p>

<p><code class="highlighter-rouge">scala
  def receive(rpc: WebSocketRPC): Option[Response] = {
    tableFut.onComplete { table =&gt;
      if (table.isFailure) {
        return None // Do not do that!
      } else { ... }
    }
  }
 </code></p>

<p><code class="highlighter-rouge">.onComplete</code> 方法接收一个匿名闭包并把它传递到一个不同的线程中。这个闭包最终会抛出一个 <code class="highlighter-rouge">NonLocalReturnControl</code> 异常，并在 __一个不同的线程中__被捕获，而这里执行的方法却没有任何影响。</p>

<p>然而，也有少数情况我们是推荐使用 <code class="highlighter-rouge">return</code> 的。</p>

<ul>
  <li>
    <p>使用 <code class="highlighter-rouge">return</code> 来简化控制流，避免增加一级缩进。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">doSomething</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="n">eq</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span>
  <span class="o">}</span>
  <span class="c1">// do something ...
</span><span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>使用 <code class="highlighter-rouge">return</code> 来提前终止循环，这样就不用额外构造状态标志。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">cond</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
</ul>

<h3 id="a-namerecursiona"><a name="recursion">递归及尾递归</a></h3>

<p><strong>避免使用递归</strong>，除非问题可以非常自然地用递归来描述（比如，图和树的遍历）。</p>

<p>对于那些你意欲使之成为尾递归的方法，请加上 <code class="highlighter-rouge">@tailrec</code> 注解以确保编译器去检查它是否真的是尾递归（你会非常惊讶地看到，由于使用了闭包和函数变换，许多看似尾递归的代码事实并非尾递归）。</p>

<p>大多数的代码使用简单的循环和状态机会更容易推理，使用尾递归反而可能会使它更加繁琐且难以理解。例如，下面的例子中，命令式的代码比尾递归版本的代码要更加易读：</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// Tail recursive version.
</span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nd">@tailrec</span>
  <span class="k">def</span> <span class="n">max0</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">pos</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">max</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">max0</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">(</span><span class="n">pos</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="n">data</span><span class="o">(</span><span class="n">pos</span><span class="o">)</span> <span class="k">else</span> <span class="n">max</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">max0</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nc">Int</span><span class="o">.</span><span class="nc">MinValue</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Explicit loop version
</span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">max</span> <span class="k">=</span> <span class="nc">Int</span><span class="o">.</span><span class="nc">MinValue</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">v</span> <span class="k">&lt;-</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">max</span> <span class="k">=</span> <span class="n">v</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">max</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-nameimplicitsimplicitsa"><a name="implicits">Implicits</a></h3>

<p><strong>避免使用 implicit</strong>，除非：</p>

<ul>
  <li>你在构建领域特定的语言（DSL）</li>
  <li>你在隐式类型参数中使用它（如：<code class="highlighter-rouge">ClassTag</code>，<code class="highlighter-rouge">TypeTag</code>）</li>
  <li>你在你自己的类中使用它（意指不要污染外部空间），以此减少类型转换的冗余度（如：Scala 闭包到 Java 闭包的转换）。</li>
</ul>

<p>当使用 implicit 时，我们应该确保另一个工程师可以直接理解使用语义，而无需去阅读隐式定义本身。Implicit 有着非常复杂的解析规则，这会使代码变得极其难以理解。Twitter 的 Effective Scala 指南中写道：「如果你发现你在使用 implicit，始终停下来问一下你自己，是否可以在不使用 implicit 的条件下达到相同的效果」。</p>

<p>如果你必需使用它们（比如：丰富 DSL），那么不要重载隐式方法，即确保每个隐式方法有着不同的名字，这样使用者就可以选择性地导入它们。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// 别这么做，这样使用者无法选择性地只导入其中一个方法。
</span><span class="k">object</span> <span class="nc">ImplicitHolder</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">toRdd</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">toRdd</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// 应该将它们定义为不同的名字：
</span><span class="k">object</span> <span class="nc">ImplicitHolder</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">intSeqToRdd</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">longSeqToRdd</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="a-nameexceptiontry--trya"><a name="exception">异常处理，Try 还是 try</a></h2>

<ul>
  <li>
    <p>不要捕获 Throwable 或 Exception 类型的异常。请使用 <code class="highlighter-rouge">scala.util.control.NonFatal</code>：</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// 异常处理；注意 NonFatal 无法匹配 InterruptedException 类型的异常
</span>  <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">InterruptedException</span> <span class="o">=&gt;</span>
    <span class="c1">// 处理 InterruptedException
</span><span class="o">}</span>
</code></pre>
    </div>
    <p>这能保证我们不会去捕获 <code class="highlighter-rouge">NonLocalReturnControl</code> 异常（正如在<a href="#return">Return 语句</a>中所解释的）。</p>
  </li>
  <li>
    <p>不要在 API 中使用 <code class="highlighter-rouge">Try</code>，即，不要在任何方法中返回 Try。对于异常执行，请显式地抛出异常，并使用 Java 风格的 try/catch 做异常处理。</p>

    <p>背景资料：Scala 提供了单子（monadic）错误处理（通过 <code class="highlighter-rouge">Try</code>，<code class="highlighter-rouge">Success</code> 和 <code class="highlighter-rouge">Failure</code>），这样便于做链式处理。然而，根据我们的经验，发现使用它通常会带来更多的嵌套层级，使得代码难以阅读。此外，对于预期错误还是异常，在语义上常常是不明晰的。因此，我们不鼓励使用 <code class="highlighter-rouge">Try</code> 来做错误处理，尤其是以下情况：</p>

    <p>一个人为的例子：</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span> <span class="o">{</span>
  <span class="cm">/** Look up a user's profile in the user database. */</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span>
<span class="o">}</span>
</code></pre>
    </div>
    <p>以下的写法会更好：</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span> <span class="o">{</span>
  <span class="cm">/**
   * Look up a user's profile in the user database.
   * @return None if the user is not found.
   * @throws DatabaseConnectionException when we have trouble connecting to the database/
   */</span>
  <span class="nd">@throws</span><span class="o">(</span><span class="nc">DatabaseConnectionException</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span>
<span class="o">}</span>
</code></pre>
    </div>
    <p>第二种写法非常明显地能让调用者知道需要处理哪些错误情况。</p>
  </li>
</ul>

<h3 id="a-nameoptionoptionsa"><a name="option">Options</a></h3>

<ul>
  <li>如果一个值可能为空，那么请使用 <code class="highlighter-rouge">Option</code>。相对于 <code class="highlighter-rouge">null</code>，<code class="highlighter-rouge">Option</code> 显式地表明了一个 API 的返回值可能为空。</li>
  <li>
    <p>构造 <code class="highlighter-rouge">Option</code> 值时，请使用 <code class="highlighter-rouge">Option</code> 而非 <code class="highlighter-rouge">Some</code>，以防那个值为 <code class="highlighter-rouge">null</code>。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">myMethod1</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">(</span><span class="n">transform</span><span class="o">(</span><span class="n">input</span><span class="o">))</span>

<span class="c1">// This is not as robust because transform can return null, and then
// myMethod2 will return Some(null).
</span><span class="k">def</span> <span class="n">myMethod2</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">transform</span><span class="o">(</span><span class="n">input</span><span class="o">))</span>
</code></pre>
    </div>
  </li>
  <li>不要使用 None 来表示异常，有异常时请显式抛出。</li>
  <li>不要在一个 <code class="highlighter-rouge">Option</code> 值上直接调用 <code class="highlighter-rouge">get</code> 方法，除非你百分百确定那个 <code class="highlighter-rouge">Option</code> 值不是 <code class="highlighter-rouge">None</code>。</li>
</ul>

<h3 id="a-namechaininga"><a name="chaining">单子链接</a></h3>

<p>单子链接是 Scala 的一个强大特性。Scala 中几乎一切都是单子（如：集合，Option，Future，Try 等），对它们的操作可以链接在一起。这是一个非常强大的概念，但你应该谨慎使用，尤其是：</p>

<ul>
  <li>避免链接（或嵌套）超过 3 个操作。</li>
  <li>如果需要花超过 5 秒钟来理解其中的逻辑，那么你应该尽量去想想有没什么办法在不使用单子链接的条件下来达到相同的效果。一般来说，你需要注意的是：不要滥用 <code class="highlighter-rouge">flatMap</code> 和 <code class="highlighter-rouge">fold</code>。</li>
  <li>链接应该在 flatMap 之后断开（因为类型发生了变化）。</li>
</ul>

<p>通过给中间结果显式地赋予一个变量名，将链接断开变成一种更加过程化的风格，能让单子链接更加易于理解。来看下面的例子：</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>
<span class="k">val</span> <span class="n">database</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Person</span><span class="o">]</span>
<span class="c1">// Sometimes the client can store "null" value in the  store "address"
</span>
<span class="c1">// A monadic chaining approach
</span><span class="k">def</span> <span class="n">getAddress</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">database</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">elem</span> <span class="k">=&gt;</span>
    <span class="n">elem</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"address"</span><span class="o">)</span>
      <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="nc">Option</span><span class="o">.</span><span class="n">apply</span><span class="o">)</span>  <span class="c1">// handle null value
</span>  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 尽管代码会长一些，但以下方法可读性更高
</span><span class="k">def</span> <span class="n">getAddress</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">database</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">None</span>
  <span class="o">}</span>

  <span class="n">database</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"address"</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">null</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">None</span>  <span class="c1">// handle null value
</span>    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">addr</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="n">addr</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre>
</div>

<h2 id="a-nameconcurrencya"><a name="concurrency">并发</a></h2>

<h3 id="a-nameconcurrency-scala-collectionscala-concurrentmapa"><a name="concurrency-scala-collection">Scala concurrent.Map</a></h3>

<p><strong>优先考虑使用 <code class="highlighter-rouge">java.util.concurrent.ConcurrentHashMap</code> 而非 <code class="highlighter-rouge">scala.collection.concurrent.Map</code></strong>。尤其是 <code class="highlighter-rouge">scala.collection.concurrent.Map</code> 中的 <code class="highlighter-rouge">getOrElseUpdate</code> 方法要慎用，它并非原子操作（这个问题在 Scala 2.11.16 中 fix 了：<a href="https://issues.scala-lang.org/browse/SI-7943">SI-7943</a>）。由于我们做的所有项目都需要在 Scala 2.10 和 Scala 2.11 上使用，因此要避免使用 <code class="highlighter-rouge">scala.collection.concurrent.Map</code>。</p>

<h3 id="a-nameconcurrency-sync-vs-map-vs-a"><a name="concurrency-sync-vs-map">显式同步 vs 并发集合</a></h3>

<p>有 3 种推荐的方法来安全地并发访问共享状态。<strong>不要混用它们</strong>，因为这会使程序变得难以推理，并且可能导致死锁。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">java.util.concurrent.ConcurrentHashMap</code>：当所有的状态都存储在一个 map 中，并且有高程度的竞争时使用。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">ConcurrentHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
</code></pre>
    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">java.util.Collections.synchronizedMap</code>：使用情景：当所有状态都存储在一个 map 中，并且预期不存在竞争情况，但你仍想确保代码在并发下是安全的。如果没有竞争出现，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Collections</span><span class="o">.</span><span class="n">synchronizedMap</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>通过同步所有临界区进行显式同步，可用于监视多个变量。与 2 相似，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Manager</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span>
    <span class="n">map</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">getCount</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span> <span class="n">count</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
</ul>

<p>注意，对于 case 1 和 case 2，不要让集合的视图或迭代器从保护区域逃逸。这可能会以一种不明显的方式发生，比如：返回了 <code class="highlighter-rouge">Map.keySet</code> 或 <code class="highlighter-rouge">Map.values</code>。如果需要传递集合的视图或值，生成一份数据拷贝再传递。</p>

<p>```scala
  val map = java.util.Collections.synchronizedMap(new java.util.HashMap[String, String])</p>

<p>// This is broken!
  def values: Iterable[String] = map.values</p>

<p>// Instead, copy the elements
  def values: Iterable[String] = map.synchronized { Seq(map.values: _*) }
  ```</p>

<h3 id="a-nameconcurrency-sync-vs-atomic-vs--vs-volatilea"><a name="concurrency-sync-vs-atomic">显式同步 vs 原子变量 vs @volatile</a></h3>

<p><code class="highlighter-rouge">java.util.concurrent.atomic</code> 包提供了对基本类型的无锁访问，比如：<code class="highlighter-rouge">AtomicBoolean</code>, <code class="highlighter-rouge">AtomicInteger</code> 和 <code class="highlighter-rouge">AtomicReference</code>。</p>

<p>始终优先考虑使用原子变量而非 <code class="highlighter-rouge">@volatile</code>，它们是相关功能的严格超集并且从代码上看更加明显。原子变量的底层实现使用了 <code class="highlighter-rouge">@volatile</code>。</p>

<p>优先考虑使用原子变量而非显式同步的情况：（1）一个对象的所有临界区更新都被限制在单个变量里并且预期会有竞争情况出现。原子变量是无锁的并且允许更为有效的竞争。（2）同步被明确地表示为 <code class="highlighter-rouge">getAndSet</code> 操作。例如：</p>

<p>```scala
  // good: 明确又有效地表达了下面的并发代码只执行一次
  val initialized = new AtomicBoolean(false)
  …
  if (!initialized.getAndSet(true)) {
    …
  }</p>

<p>// poor: 下面的同步就没那么明晰，而且会出现不必要的同步
  val initialized = false
  …
  var wasInitialized = false
  synchronized {
    wasInitialized = initialized
    initialized = true
  }
  if (!wasInitialized) {
    …
  }
  ```</p>

<h3 id="a-nameconcurrency-private-thisa"><a name="concurrency-private-this">私有字段</a></h3>

<p>注意，<code class="highlighter-rouge">private</code> 字段仍然可以被相同类的其它实例所访问，所以仅仅通过 <code class="highlighter-rouge">this.synchronized</code>（或 <code class="highlighter-rouge">synchronized</code>）来保护它从技术上来说是不够的，不过你可以通过 <code class="highlighter-rouge">private[this]</code> 修饰私有字段来达到目的。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// 以下代码仍然是不安全的。
</span><span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">inc</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 以下代码是安全的。
</span><span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">inc</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-nameconcurrency-isolationa"><a name="concurrency-isolation">隔离</a></h3>

<p>一般来说，并发和同步逻辑应该尽可能地被隔离和包含起来。这实际上意味着：</p>

<ul>
  <li>避免在 API 层面、面向用户的方法以及回调中暴露同步原语。</li>
  <li>对于复杂模块，创建一个小的内部模块来包含并发原语。</li>
</ul>

<h2 id="a-nameperfa"><a name="perf">性能</a></h2>

<p>对于你写的绝大多数代码，性能都不应该成为一个问题。然而，对于一些性能敏感的代码，以下有一些小建议：</p>

<h3 id="a-nameperf-microbenchmarksmicrobenchmarksa"><a name="perf-microbenchmarks">Microbenchmarks</a></h3>

<p>由于 Scala 编译器和 JVM JIT 编译器会对你的代码做许多神奇的事情，因此要写出一个好的微基准程序（microbenchmark）是极其困难的。更多的情况往往是你的微基准程序并没有测量你想要测量的东西。</p>

<p>如果你要写一个微基准程序，请使用 <a href="http://openjdk.java.net/projects/code-tools/jmh/">jmh</a>。请确保你阅读了<a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">所有的样例</a>，这样你才理解微基准程序中「死代码」移除、常量折叠以及循环展开的效果。</p>

<h3 id="a-nameperf-whileloopstraversal--zipwithindexa"><a name="perf-whileloops">Traversal 与 zipWithIndex</a></h3>

<p>使用 <code class="highlighter-rouge">while</code> 循环而非 <code class="highlighter-rouge">for</code> 循环或函数变换（如：<code class="highlighter-rouge">map</code>、<code class="highlighter-rouge">foreach</code>），for 循环和函数变换非常慢（由于虚函数调用和装箱的缘故）。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code>
<span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="c1">// array of ints
// 偶数位置的数置零
</span><span class="k">val</span> <span class="n">newArr</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">elem</span>
<span class="o">}</span>

<span class="c1">// 这是上面代码的高性能版本
</span><span class="k">val</span> <span class="n">newArr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">arr</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="n">newArr</span><span class="o">.</span><span class="n">length</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">newArr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">arr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-nameperf-optionoption--nulla"><a name="perf-option">Option 与 null</a></h3>

<p>对于性能有要求的代码，优先考虑使用 <code class="highlighter-rouge">null</code> 而不是 <code class="highlighter-rouge">Option</code>，以此避免虚函数调用以及装箱操作。用 Nullable 注解明确标示出可能为 <code class="highlighter-rouge">null</code> 的值。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="nd">@javax</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="nc">Nullable</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">nullableField</span><span class="k">:</span> <span class="kt">Bar</span> <span class="o">=</span> <span class="k">_</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-nameperf-collectionscala-a"><a name="perf-collection">Scala 集合库</a></h3>

<p>对于性能有要求的代码，优先考虑使用 Java 集合库而非 Scala 集合库，因为一般来说，Scala 集合库要比 Java 的集合库慢。</p>

<h3 id="a-nameperf-privateprivatethisa"><a name="perf-private">private[this]</a></h3>

<p>对于性能有要求的代码，优先考虑使用 <code class="highlighter-rouge">private[this]</code> 而非 <code class="highlighter-rouge">private</code>。<code class="highlighter-rouge">private[this]</code> 生成一个字段而非生成一个访问方法。根据我们的经验，JVM JIT 编译器并不总是会内联 <code class="highlighter-rouge">private</code> 字段的访问方法，因此通过使用
<code class="highlighter-rouge">private[this]</code> 来确保没有虚函数调用会更保险。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">field1</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">field2</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">perfSensitiveMethod</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">field1</span>  <span class="c1">// This might invoke a virtual method call
</span>      <span class="n">field2</span>  <span class="c1">// This is just a field access
</span>      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="a-namejava-java-a"><a name="java">与 Java 的互操作性</a></h2>

<p>本节内容介绍的是构建 Java 兼容 API 的准则。如果你构建的组件并不需要与 Java 有交互，那么请无视这一节。这一节的内容主要是从我们开发 Spark 的 Java API 的经历中得出的。</p>

<h3 id="a-namejava-missing-featuresscala--java-a"><a name="java-missing-features">Scala 中缺失的 Java 特性</a></h3>

<p>以下的 Java 特性在 Scala 中是没有的，如果你需要使用以下特性，请在 Java 中定义它们。然而，需要提醒一点的是，你无法为 Java 源文件生成 ScalaDoc。</p>

<ul>
  <li>静态字段</li>
  <li>静态内部类</li>
  <li>Java 枚举</li>
  <li>注解</li>
</ul>

<h3 id="a-namejava-traitstraits-a"><a name="java-traits">Traits 与抽象类</a></h3>

<p>对于允许从外部实现的接口，请记住以下几点：</p>

<ul>
  <li>包含了默认方法实现的 trait 是无法在 Java 中使用的，请使用抽象类来代替。</li>
  <li>一般情况下，请避免使用 trait，除非你百分百确定这个接口即使在未来也不会有默认的方法实现。</li>
</ul>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// 以下默认实现无法在 Java 中使用
</span><span class="k">trait</span> <span class="nc">Listener</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">onTermination</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 可以在 Java 中使用
</span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Listener</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">onTermination</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-namejava-type-aliasa"><a name="java-type-alias">类型别名</a></h3>

<p>不要使用类型别名，它们在字节码和 Java 中是不可见的。</p>

<h3 id="a-namejava-default-param-valuesa"><a name="java-default-param-values">默认参数值</a></h3>

<p>不要使用默认参数值，通过重载方法来代替。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">// 打破了与 Java 的互操作性
</span><span class="k">def</span> <span class="n">sample</span><span class="o">(</span><span class="n">ratio</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">withReplacement</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// 以下方法是 work 的
</span><span class="k">def</span> <span class="n">sample</span><span class="o">(</span><span class="n">ratio</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">withReplacement</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">def</span> <span class="n">sample</span><span class="o">(</span><span class="n">ratio</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">sample</span><span class="o">(</span><span class="n">ratio</span><span class="o">,</span> <span class="n">withReplacement</span> <span class="k">=</span> <span class="kc">false</span><span class="o">)</span>
</code></pre>
</div>

<h3 id="a-namejava-multi-param-lista"><a name="java-multi-param-list">多参数列表</a></h3>

<p>不要使用多参数列表。</p>

<h3 id="a-namejava-varargsa"><a name="java-varargs">可变参数</a></h3>

<ul>
  <li>
    <p>为可变参数方法添加 <code class="highlighter-rouge">@scala.annotation.varargs</code> 注解，以确保它能在 Java 中使用。Scala 编译器会生成两个方法，一个给 Scala 使用（字节码参数是一个 Seq），另一个给 Java 使用（字节码参数是一个数组）。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="nd">@scala</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">varargs</span>
<span class="k">def</span> <span class="n">select</span><span class="o">(</span><span class="n">exprs</span><span class="k">:</span> <span class="kt">Expression*</span><span class="o">)</span><span class="k">:</span> <span class="kt">DataFrame</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>需要注意的一点是，由于 Scala 编译器的一个 bug（<a href="https://issues.scala-lang.org/browse/SI-1459">SI-1459</a>，<a href="https://issues.scala-lang.org/browse/SI-9013">SI-9013</a>），抽象的变参方法是无法在 Java 中使用的。</p>
  </li>
  <li>
    <p>重载变参方法时要小心，用另一个类型去重载变参方法会破坏源码的兼容性。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Database</span> <span class="o">{</span>
  <span class="nd">@scala</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">varargs</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">...</span>

  <span class="c1">// 当调用无参的 remove 方法时会出问题。
</span>  <span class="nd">@scala</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">varargs</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">People*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// remove 方法有歧义，因此编译不过。
</span><span class="k">new</span> <span class="nc">Database</span><span class="o">().</span><span class="n">remove</span><span class="o">()</span>
</code></pre>
    </div>
    <p>一种解决方法是，在可变参数前显式地定义第一个参数：</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Database</span> <span class="o">{</span>
  <span class="nd">@scala</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">varargs</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">...</span>

  <span class="c1">// 以下重载是 OK 的。
</span>  <span class="nd">@scala</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">varargs</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">People</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">People*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
</ul>

<h3 id="a-namejava-implicitsimplicitsa"><a name="java-implicits">Implicits</a></h3>

<p>不要为类或方法使用 implicit，包括了不要使用 <code class="highlighter-rouge">ClassTag</code> 和 <code class="highlighter-rouge">TypeTag</code>。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">JavaFriendlyAPI</span> <span class="o">{</span>
  <span class="c1">// 以下定义对 Java 是不友好的，因为方法中包含了一个隐式参数（ClassTag）。
</span>  <span class="k">def</span> <span class="n">convertTo</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">]()</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="a-namejava-companion-objecta"><a name="java-companion-object">伴生对象，静态方法与字段</a></h3>

<p>当涉及到伴生对象和静态方法/字段时，有几件事情是需要注意的：</p>

<ul>
  <li>
    <p>伴生对象在 Java 中的使用是非常别扭的（伴生对象 <code class="highlighter-rouge">Foo</code> 会被定义为 <code class="highlighter-rouge">Foo$</code> 类内的一个类型为 <code class="highlighter-rouge">Foo$</code> 的静态字段 <code class="highlighter-rouge">MODULE$</code>）。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Foo</span>

<span class="c1">// 等价于以下的 Java 代码
</span><span class="n">public</span> <span class="k">class</span> <span class="nc">Foo$</span> <span class="o">{</span>
  <span class="nc">Foo</span><span class="n">$</span> <span class="nc">MODULE</span><span class="n">$</span> <span class="k">=</span> <span class="c1">// 对象的实例化
</span><span class="o">}</span>
</code></pre>
    </div>
    <p>如果非要使用伴生对象，可以在一个单独的类中创建一个 Java 静态字段。</p>
  </li>
  <li>不幸的是，没有办法在 Scala 中定义一个 JVM 静态字段。请创建一个 Java 文件来定义它。</li>
  <li>
    <p>伴生对象里的方法会被自动转成伴生类里的静态方法，除非方法名有冲突。确保静态方法正确生成的最好方式是用 Java 写一个测试文件，然后调用生成的静态方法。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">method2</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">method1</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>  <span class="c1">// 静态方法 Foo.method1 会被创建（字节码）
</span>  <span class="k">def</span> <span class="n">method2</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>  <span class="c1">// 静态方法 Foo.method2 不会被创建
</span><span class="o">}</span>

<span class="c1">// FooJavaTest.java (in test/scala/com/databricks/...)
</span><span class="n">public</span> <span class="k">class</span> <span class="nc">FooJavaTest</span> <span class="o">{</span>
  <span class="n">public</span> <span class="n">static</span> <span class="n">compileTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Foo</span><span class="o">.</span><span class="n">method1</span><span class="o">();</span>  <span class="c1">// 正常编译
</span>    <span class="nc">Foo</span><span class="o">.</span><span class="n">method2</span><span class="o">();</span>  <span class="c1">// 编译失败，因为 method2 并没有生成
</span>  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>样例对象（case object） MyClass 的类型并不是 MyClass。</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">case</span> <span class="k">object</span> <span class="nc">MyClass</span>

<span class="c1">// Test.java
</span><span class="k">if</span> <span class="o">(</span><span class="nc">MyClass</span><span class="n">$</span><span class="o">.</span><span class="nc">MODULE</span> <span class="n">instanceof</span> <span class="nc">MyClass</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 上述条件始终为 false
</span><span class="o">}</span>
</code></pre>
    </div>
    <p>要实现正确的类型层级结构，请定义一个伴生类，然后用一个样例对象去继承它：</p>

    <div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">MyClass</span> <span class="k">extends</span> <span class="nc">MyClass</span>
</code></pre>
    </div>
  </li>
</ul>

<h2 id="a-namemisca"><a name="misc">其它</a></h2>

<h3 id="a-namemisccurrenttimemillisvsnanotime-nanotime--currenttimemillisa"><a name="misc_currentTimeMillis_vs_nanoTime">优先使用 nanoTime 而非 currentTimeMillis</a></h3>

<p>当要计算<em>持续时间</em>或者检查<em>超时</em>的时候，避免使用 <code class="highlighter-rouge">System.currentTimeMillis()</code>。请使用 <code class="highlighter-rouge">System.nanoTime()</code>，即使你对亚毫秒级的精度并不感兴趣。</p>

<p><code class="highlighter-rouge">System.currentTimeMillis()</code> 返回的是当前的时钟时间，并且会跟进系统时钟的改变。因此，负的时钟调整可能会导致超时而挂起很长一段时间（直到时钟时间赶上先前的值）。这种情况可能发生在网络已经中断一段时间，ntpd 走过了一步之后。最典型的例子是，在系统启动的过程中，DHCP 花费的时间要比平常的长。这可能会导致非常难以理解且难以重现的问题。而 <code class="highlighter-rouge">System.nanoTime()</code> 则可以保证是单调递增的，与时钟变化无关。</p>

<p>注意事项：</p>

<ul>
  <li>永远不要序列化一个绝对的 <code class="highlighter-rouge">nanoTime()</code> 值或是把它传递给另一个系统。绝对的 <code class="highlighter-rouge">nanoTime()</code> 值是无意义的、与系统相关的，并且在系统重启时会重置。</li>
  <li>绝对的 <code class="highlighter-rouge">nanoTime()</code> 值并不保证总是正数（但 <code class="highlighter-rouge">t2 - t1</code> 能确保总是产生正确的值）。</li>
  <li><code class="highlighter-rouge">nanoTime()</code> 每 292 年就会重新计算起。所以，如果你的 Spark 任务需要花非常非常非常长的时间，你可能需要别的东西来处理了：）</li>
</ul>

<h3 id="a-namemiscuriurl-uri--urla"><a name="misc_uri_url">优先使用 URI 而非 URL</a></h3>

<p>当存储服务的 URL 时，你应当使用 <code class="highlighter-rouge">URI</code> 来表示。</p>

<p><code class="highlighter-rouge">URL</code> 的<a href="http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)">相等性检查</a>实际上执行了一次网络调用（这是阻塞的）来解析 IP 地址。<code class="highlighter-rouge">URI</code> 类在表示能力上是 <code class="highlighter-rouge">URL</code> 的超集，并且它执行的是字段的相等性检查。</p>

<p>https://github.com/Hawstein/scala-style-guide/blob/master/README-ZH.md</p>


                <hr>


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/language/2016/09/05/Scala-Lesson15/" data-toggle="tooltip" data-placement="top" title="Scala Lesson 15">
                        Previous<br>
                        <span>Scala Lesson 15</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/blog/2016/09/05/travel-map/" data-toggle="tooltip" data-placement="top" title="travel Map">
                        Next<br>
                        <span>travel Map</span>
                        </a>
                    </li>
                    
                </ul>

                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                        data-thread-key="/language/2016/09/05/Scala-Lesson16"
                        data-title="Scala Lesson 16"
                        data-url="http://machinelearningadvance.com/language/2016/09/05/Scala-Lesson16/" >
                    </div>

                </div>
                <!-- 多说评论框 end -->
                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#ME" title="ME" rel="4">
                                ME
                                </a>
                            
        				
                            
                				<a href="/tags/#Other" title="Other" rel="4">
                                Other
                                </a>
                            
        				
                            
                				<a href="/tags/#CFAL1" title="CFAL1" rel="9">
                                CFAL1
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#maths" title="maths" rel="2">
                                maths
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Big Data" title="Big Data" rel="17">
                                Big Data
                                </a>
                            
        				
                            
                				<a href="/tags/#大数据" title="大数据" rel="17">
                                大数据
                                </a>
                            
        				
                            
                				<a href="/tags/#IT" title="IT" rel="3">
                                IT
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Scala" title="Scala" rel="23">
                                Scala
                                </a>
                            
        				
                            
                				<a href="/tags/#Spark" title="Spark" rel="2">
                                Spark
                                </a>
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://wepiaofei.github.io/blog/">前端神盾局</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>



<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"machinelearningadvance"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
<!-- 多说公共JS代码 end -->
<!-- 多说公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/u/2672280861">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    <li>
                        <a target="_blank" href="https://www.facebook.com/davidyjun">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/helloourworld">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/lijun-yu-13b9b475">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Big Data Memo 2016
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-82819752-1';
    var _gaDomain = 'machinelearningadvance.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '863b1f46c83a8e14e47782106aee7e7f';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="/images/background.jpg" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
